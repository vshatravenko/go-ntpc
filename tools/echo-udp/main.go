package main

import (
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"strings"
)

/*
	Use this package to inspect UDP datagrams generated by the client
	and test the basic UDP exchange process
*/

var (
	defaultListenAddr = &net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 4269}
	network           = "udp4"
	bufSize           = 4096
)

func main() {
	var err error
	listenAddr := defaultListenAddr
	if len(os.Args) == 2 {
		listenAddr, err = parseAddrFromArgs(os.Args)
		if err != nil {
			log.Fatalf("could not parse listen address: %s", err.Error())
		}
	}

	conn, err := net.ListenUDP(network, listenAddr)
	if err != nil {
		log.Fatalf("could not bind on %v: %s", listenAddr, err.Error())
	}
	log.Printf("Listening for UDP traffic on %v", listenAddr)

	buf := make([]byte, bufSize)

	for {
		count, remoteAddr, err := conn.ReadFromUDP(buf)
		if err != nil {
			log.Printf("read err from %v: %s", remoteAddr, err)
		} else {
			log.Printf("read %d bytes from %v: %v", count, remoteAddr, buf[:count])
		}

		count, err = conn.WriteTo(buf[0:count], remoteAddr)
		if err != nil {
			log.Printf("write err to %v: %s", remoteAddr, err)
		} else {
			log.Printf("wrote %d bytes to %v", count, remoteAddr)
		}
	}
}

func parseAddrFromArgs(args []string) (*net.UDPAddr, error) {
	components := strings.Split(args[1], ":")

	if len(components) != 2 {
		return nil, fmt.Errorf("%s does not comply with *ip*:*port* format")
	}

	ip := net.ParseIP(components[0])

	port, err := strconv.Atoi(components[1])
	if err != nil {
		return nil, fmt.Errorf("cannot parse %s as port number: %s", components[1], err.Error())
	}

	return &net.UDPAddr{IP: ip, Port: port}, nil
}
